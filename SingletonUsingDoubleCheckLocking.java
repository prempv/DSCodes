package objects.singleton;

/**
 * Singleton using double checked locking.
 * Why Volatile:
 * Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
 * The code generated by the compiler is allowed to update the shared variable to point to a partially constructed
 * object before A has finished performing the initialization.
 * Thread B notices that the shared variable has been initialized (or so it appears), and returns its value.
 * Because thread B believes the value is already initialized, it does not acquire the lock.
 * If B uses the object before all of the initialization done by A is seen by B the program will likely crash.
 * User: rpanjrath
 * Date: 10/15/13
 * Time: 12:35 PM
 */
public class SingletonUsingDoubleCheckLocking {

    private volatile SingletonUsingDoubleCheckLocking doubleCheckLocking;

    private SingletonUsingDoubleCheckLocking() {

    }

    public SingletonUsingDoubleCheckLocking getInstance() {
        if (doubleCheckLocking == null) {
            synchronized (SingletonUsingDoubleCheckLocking.class) {
                if (doubleCheckLocking == null) {
                    return new SingletonUsingDoubleCheckLocking();
                }
            }
        }
        return doubleCheckLocking;
    }
}
